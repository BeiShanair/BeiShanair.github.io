<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>方块实体2 1.21 Fabric | Tomorrow-Land</title><meta name="author" content="BeiShan_Besson"><meta name="copyright" content="BeiShan_Besson"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="方块实体的第二个例子，完整实现可处理物品的方块实体">
<meta property="og:type" content="article">
<meta property="og:title" content="方块实体2 1.21 Fabric">
<meta property="og:url" content="https://beishanair.github.io/2024/10/26/121/polishingmachine121/index.html">
<meta property="og:site_name" content="Tomorrow-Land">
<meta property="og:description" content="方块实体的第二个例子，完整实现可处理物品的方块实体">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://beishanair.github.io/pic/121/031.jpg">
<meta property="article:published_time" content="2024-10-26T07:00:00.000Z">
<meta property="article:modified_time" content="2025-04-21T00:39:13.121Z">
<meta property="article:author" content="BeiShan_Besson">
<meta property="article:tag" content="Fabric">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://beishanair.github.io/pic/121/031.jpg"><link rel="shortcut icon" href="/pic/BS.png"><link rel="canonical" href="https://beishanair.github.io/2024/10/26/121/polishingmachine121/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '方块实体2 1.21 Fabric',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-04-21 08:39:13'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/pic/BS.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">68</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Menu</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/pic/LDD_FF.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Tomorrow-Land"><span class="site-name">Tomorrow-Land</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Menu</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">方块实体2 1.21 Fabric</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-26T07:00:00.000Z" title="发表于 2024-10-26 15:00:00">2024-10-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-21T00:39:13.121Z" title="更新于 2025-04-21 08:39:13">2025-04-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Tutorial/">Tutorial</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>30分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="方块实体2 1.21 Fabric"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="本篇教程的视频"><a href="#本篇教程的视频" class="headerlink" title="本篇教程的视频"></a>本篇教程的视频</h1><iframe src="//player.bilibili.com/player.html?isOutside=true&aid=112946734760902&bvid=BV1S7YZepEQu&cid=500001646507942&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="800" height="450"></iframe>

<h1 id="本篇教程的源代码"><a href="#本篇教程的源代码" class="headerlink" title="本篇教程的源代码"></a>本篇教程的源代码</h1><h2 id="Github地址：TutorialMod-PolishingMachine-1-21"><a href="#Github地址：TutorialMod-PolishingMachine-1-21" class="headerlink" title="Github地址：TutorialMod-PolishingMachine-1.21"></a>Github地址：<a target="_blank" rel="noopener" href="https://github.com/BeiShanair/tutorialmod-template-1.21/tree/%2329-blockEntity2">TutorialMod-PolishingMachine-1.21</a></h2><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>前面我们简单抄了一个箱子，也就是可以储物的方块实体，这次我们来做一个可以处理物品的方块实体，也就是大部分工业模组中的常见的方块实体</p>
<p>这一次我们将完整实现一个带有<code>GUI</code>的方块实体，包括<code>方块本身</code>（Block）、<code>方块实体</code>（BlockEntity）、<code>屏幕</code>（Screen）、<code>屏幕处理器</code>（ScreenHandler）以及<code>渲染器</code>（Renderer）</p>
<p>而后面的教程将实现与这个方块实体适配的<code>配方类型</code>，而后适配<code>REI</code></p>
<p><code>教程的篇幅会很长，请耐心看完</code></p>
<p><code>由于方块实体的实现较为复杂，请留意本篇教程中高亮显示的部分，避免遗漏</code></p>
<h1 id="方块类"><a href="#方块类" class="headerlink" title="方块类"></a>方块类</h1><h2 id="创建PolishingMachine类"><a href="#创建PolishingMachine类" class="headerlink" title="创建PolishingMachine类"></a>创建PolishingMachine类</h2><p>首先我们创建一个<code>PolishingMachine</code>类，这个类继承自<code>BlockWithEntity</code>，并且实现<code>BlockEntityProvider</code>接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolishingMachine</span> <span class="keyword">extends</span> <span class="title class_">BlockWithEntity</span> <span class="keyword">implements</span> <span class="title class_">BlockEntityProvider</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PolishingMachine</span><span class="params">(Settings settings)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(settings);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> MapCodec&lt;? <span class="keyword">extends</span> <span class="title class_">BlockWithEntity</span>&gt; getCodec() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BlockEntity <span class="title function_">createBlockEntity</span><span class="params">(BlockPos pos, BlockState state)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现<code>super</code>函数，另外也要重写两个方法，一个是<code>getCodec</code>，这是编解码器；另一个是<code>createBlockEntity</code>，这是创建方块实体的方法</p>
<p><code>BlockWithEntity</code>这个类在原版中是很多方块实体的父类，我们前面抄的箱子，也是继承这个类的</p>
<p>我们按住<code>Ctrl</code>点击<code>BlockWithEntity</code>跳转到源代码，并在<code>BlockWithEntity</code>高亮显示时，按下<code>Ctrl+H</code>，可以查看它的作用域，即查看其子类</p>
<p>原版的方块实体其实也够我们研究一阵子了，当然，工业模组里的方块实体也是如此</p>
<h2 id="设置编解码器"><a href="#设置编解码器" class="headerlink" title="设置编解码器"></a>设置编解码器</h2><p>我们先来实现<code>getCodec</code>方法，这里需要一个编解码器，我们直接用最简单的写法即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MapCodec&lt;PolishingMachine&gt; CODEC = createCodec(PolishingMachine::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>
<p>前面我们写箱子的时候，也是用的同样的语句</p>
<p>而后，我们在<code>getCodec</code>方法中返回这个编解码器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> MapCodec&lt;? <span class="keyword">extends</span> <span class="title class_">BlockWithEntity</span>&gt; getCodec() &#123;</span><br><span class="line">	<span class="keyword">return</span> CODEC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="设置碰撞箱"><a href="#设置碰撞箱" class="headerlink" title="设置碰撞箱"></a>设置碰撞箱</h2><p>我们此次制作的模型还是拿<code>BlockBench</code>做的，并不是一个完整的方块，所以我们需要自己设置<code>碰撞箱</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">VoxelShape</span> <span class="variable">SHAPE</span> <span class="operator">=</span> Block.createCuboidShape(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">16</span>, <span class="number">10</span>, <span class="number">16</span>);</span><br></pre></td></tr></table></figure>
<p>这是一个<code>VoxelShape</code>，<code>createCuboidShape</code>里面的参数是方块<code>起点</code>和<code>终点</code>的坐标，完整方块是<code>0,0,0</code>到<code>16,16,16</code></p>
<p>我们设置了一个<code>16*10*16</code>的立方体，它的高度只有10个单位，比完整的方块少6个单位</p>
<p>随后重写<code>getOutlineShape</code>方法，返回这个<code>VoxelShape</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> VoxelShape <span class="title function_">getOutlineShape</span><span class="params">(BlockState state, BlockView world, BlockPos pos, ShapeContext context)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> SHAPE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="设置渲染"><a href="#设置渲染" class="headerlink" title="设置渲染"></a>设置渲染</h2><p>和前面一样，我们还得设置这个方块的渲染，重写<code>getRenderType</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> BlockRenderType <span class="title function_">getRenderType</span><span class="params">(BlockState state)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> BlockRenderType.MODEL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们让其渲染为自身模型即可</p>
<h2 id="设置状态改变"><a href="#设置状态改变" class="headerlink" title="设置状态改变"></a>设置状态改变</h2><p>我们接下来重写<code>onStateReplaced</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onStateReplaced</span><span class="params">(BlockState state, World world, BlockPos pos, BlockState newState, <span class="type">boolean</span> moved)</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>这里我们先空着，因为我们的方块实体还没写</code></p>
<p>这个方法是当我们的方块<code>被破坏</code>以后，如果说你的方块里面有东西，那它会将里面的东西掉落出来</p>
<p>比如原版的箱子，被破坏掉以后，箱子里面的东西都会被掉落出来</p>
<h2 id="设置使用方法"><a href="#设置使用方法" class="headerlink" title="设置使用方法"></a>设置使用方法</h2><p>再一个我们来写使用这个方块时的方法，重写<code>onUse</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> ActionResult <span class="title function_">onUse</span><span class="params">(BlockState state, World world, BlockPos pos, PlayerEntity player, BlockHitResult hit)</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法我们也见到很多次了吧，因为我们这里实现的是一个有<code>GUI</code>的方块，与玩家交互时，它得弹出一个<code>GUI</code>，我们就需要在这个方法里面设置</p>
<p><code>当然，因为我们方块实体和屏幕都没有写，所以这里也先空着</code></p>
<h2 id="设置Ticker"><a href="#设置Ticker" class="headerlink" title="设置Ticker"></a>设置Ticker</h2><p>最后我们还得重写一个<code>getTicker</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">BlockEntity</span>&gt; BlockEntityTicker&lt;T&gt; <span class="title function_">getTicker</span><span class="params">(World world, BlockState state, BlockEntityType&lt;T&gt; type)</span> &#123;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>每个游戏刻都会调用这个方法来更新方块实体的状态，该方法在客户端和服务端都会被调用</code></p>
<p>它可以验证传递的<code>方块实体类型</code>（BlockEntityType）是否是该方块期望的类型，以防止当前方块与方块实体之间冲突而导致的游戏崩溃</p>
<p><code>这里我们还没有方块实体，所以也先空着</code></p>
<h1 id="ImplementedInventory"><a href="#ImplementedInventory" class="headerlink" title="ImplementedInventory"></a>ImplementedInventory</h1><p>这里我们直接从<code>Fabric</code>的<code>Wiki</code>上搬一个接口下来，<code>ImplementedInventory</code>，这个是用于实现简单的<code>SidedInventory</code>，帮助我们更好地写<code>方块实体物品栏</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A simple &#123;<span class="doctag">@code</span> SidedInventory&#125; implementation with only default methods + an item list getter.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;h2&gt;Reading and writing to tags&lt;/h2&gt;</span></span><br><span class="line"><span class="comment"> * Use &#123;<span class="doctag">@link</span> Inventories#writeNbt(NbtCompound, DefaultedList, RegistryWrapper.WrapperLookup)&#125; and &#123;<span class="doctag">@link</span> Inventories#readNbt(NbtCompound, DefaultedList, RegistryWrapper.WrapperLookup)&#125;</span></span><br><span class="line"><span class="comment"> * on &#123;<span class="doctag">@linkplain</span> #getItems() the item list&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * License: &lt;a href=&quot;https://creativecommons.org/publicdomain/zero/1.0/&quot;&gt;CC0&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juuz</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ImplementedInventory</span> <span class="keyword">extends</span> <span class="title class_">SidedInventory</span> &#123;</span><br><span class="line">    <span class="comment">// 这个接口的作用是实现一个简单的SidedInventory，只有默认方法和一个获取物品列表的方法，便于我们在BlockEntity中使用</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets the item list of this inventory.</span></span><br><span class="line"><span class="comment">     * Must return the same instance every time it&#x27;s called.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the item list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    DefaultedList&lt;ItemStack&gt; <span class="title function_">getItems</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates an inventory from the item list.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> items the item list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a new inventory</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> ImplementedInventory <span class="title function_">of</span><span class="params">(DefaultedList&lt;ItemStack&gt; items)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> () -&gt; items;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new inventory with the size.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> size the inventory size</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a new inventory</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> ImplementedInventory <span class="title function_">ofSize</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> of(DefaultedList.ofSize(size, ItemStack.EMPTY));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SidedInventory</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets the available slots to automation on the side.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The default implementation returns an array of all slots.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> side the side</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the available slots</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">int</span>[] getAvailableSlots(Direction side) &#123;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[getItems().size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; result.length; i++) &#123;</span><br><span class="line">            result[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns true if the stack can be inserted in the slot at the side.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The default implementation returns true.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> slot the slot</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stack the stack</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> side the side</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if the stack can be inserted</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">canInsert</span><span class="params">(<span class="type">int</span> slot, ItemStack stack, <span class="meta">@Nullable</span> Direction side)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns true if the stack can be extracted from the slot at the side.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The default implementation returns true.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> slot the slot</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stack the stack</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> side the side</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if the stack can be extracted</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">canExtract</span><span class="params">(<span class="type">int</span> slot, ItemStack stack, Direction side)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inventory</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the inventory size.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The default implementation returns the size of &#123;<span class="doctag">@link</span> #getItems()&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the inventory size</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getItems().size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if this inventory has only empty stacks, false otherwise</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size(); i++) &#123;</span><br><span class="line">            <span class="type">ItemStack</span> <span class="variable">stack</span> <span class="operator">=</span> getStack(i);</span><br><span class="line">            <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets the item in the slot.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> slot the slot</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the item in the slot</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">default</span> ItemStack <span class="title function_">getStack</span><span class="params">(<span class="type">int</span> slot)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getItems().get(slot);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Takes a stack of the size from the slot.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;(default implementation) If there are less items in the slot than what are requested,</span></span><br><span class="line"><span class="comment">     * takes all items in that slot.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> slot the slot</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count the item count</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a stack</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">default</span> ItemStack <span class="title function_">removeStack</span><span class="params">(<span class="type">int</span> slot, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">        <span class="type">ItemStack</span> <span class="variable">result</span> <span class="operator">=</span> Inventories.splitStack(getItems(), slot, count);</span><br><span class="line">        <span class="keyword">if</span> (!result.isEmpty()) &#123;</span><br><span class="line">            markDirty();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes the current stack in the &#123;<span class="doctag">@code</span> slot&#125; and returns it.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The default implementation uses &#123;<span class="doctag">@link</span> Inventories#removeStack(List, int)&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> slot the slot</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the removed stack</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">default</span> ItemStack <span class="title function_">removeStack</span><span class="params">(<span class="type">int</span> slot)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Inventories.removeStack(getItems(), slot);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Replaces the current stack in the &#123;<span class="doctag">@code</span> slot&#125; with the provided stack.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;If the stack is too big for this inventory (&#123;<span class="doctag">@link</span> Inventory#getMaxCountPerStack()&#125;),</span></span><br><span class="line"><span class="comment">     * it gets resized to this inventory&#x27;s maximum amount.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> slot the slot</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stack the stack</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">setStack</span><span class="params">(<span class="type">int</span> slot, ItemStack stack)</span> &#123;</span><br><span class="line">        getItems().set(slot, stack);</span><br><span class="line">        <span class="keyword">if</span> (stack.getCount() &gt; getMaxCountPerStack()) &#123;</span><br><span class="line">            stack.setCount(getMaxCountPerStack());</span><br><span class="line">        &#125;</span><br><span class="line">        markDirty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Clears &#123;<span class="doctag">@linkplain</span> #getItems() the item list&#125;&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        getItems().clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">markDirty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Override if you want behavior.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">canPlayerUse</span><span class="params">(PlayerEntity player)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本身源代码里面也有注释，可以自己看看</p>
<h1 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h1><h2 id="创建BlockPosPayload类"><a href="#创建BlockPosPayload类" class="headerlink" title="创建BlockPosPayload类"></a>创建BlockPosPayload类</h2><p>这个类是一个接口，用于传递<code>BlockPos</code>，用于待会写的网络通信的编解码器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This file is part of RebornCore, licensed under the MIT License (MIT).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2024 TeamReborn</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Permission is hereby granted, free of charge, to any person obtaining a copy</span></span><br><span class="line"><span class="comment"> * of this software and associated documentation files (the &quot;Software&quot;), to deal</span></span><br><span class="line"><span class="comment"> * in the Software without restriction, including without limitation the rights</span></span><br><span class="line"><span class="comment"> * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell</span></span><br><span class="line"><span class="comment"> * copies of the Software, and to permit persons to whom the Software is</span></span><br><span class="line"><span class="comment"> * furnished to do so, subject to the following conditions:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The above copyright notice and this permission notice shall be included in all</span></span><br><span class="line"><span class="comment"> * copies or substantial portions of the Software.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span></span><br><span class="line"><span class="comment"> * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span></span><br><span class="line"><span class="comment"> * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span></span><br><span class="line"><span class="comment"> * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span></span><br><span class="line"><span class="comment"> * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</span></span><br><span class="line"><span class="comment"> * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span></span><br><span class="line"><span class="comment"> * SOFTWARE.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.besson.tutorialmod.data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.minecraft.block.entity.BlockEntity;</span><br><span class="line"><span class="keyword">import</span> net.minecraft.block.entity.BlockEntityType;</span><br><span class="line"><span class="keyword">import</span> net.minecraft.entity.player.PlayerEntity;</span><br><span class="line"><span class="keyword">import</span> net.minecraft.registry.Registries;</span><br><span class="line"><span class="keyword">import</span> net.minecraft.screen.ScreenHandler;</span><br><span class="line"><span class="keyword">import</span> net.minecraft.server.network.ServerPlayerEntity;</span><br><span class="line"><span class="keyword">import</span> net.minecraft.util.math.BlockPos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BlockPosPayload</span> &#123;</span><br><span class="line">    BlockPos <span class="title function_">pos</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">isWithinDistance</span><span class="params">(PlayerEntity player,<span class="type">double</span> distance)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> player.getBlockPos().isWithinDistance(pos(), distance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">canUse</span><span class="params">(ServerPlayerEntity player, Predicate&lt;ScreenHandler&gt; screenHandlerPredicate)</span> &#123;</span><br><span class="line">        <span class="type">ScreenHandler</span> <span class="variable">currentScreenHandler</span> <span class="operator">=</span> player.currentScreenHandler;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currentScreenHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!screenHandlerPredicate.test(currentScreenHandler)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> currentScreenHandler.canUse(player);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> &lt;T <span class="keyword">extends</span> <span class="title class_">BlockEntity</span>&gt; T <span class="title function_">getBlockEntity</span><span class="params">(BlockEntityType&lt;T&gt; type, PlayerEntity player)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isWithinDistance(player, <span class="number">64</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Player cannot use this block entity as its too far away&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">BlockEntity</span> <span class="variable">blockEntity</span> <span class="operator">=</span> getBlockEntity(player);</span><br><span class="line">        <span class="keyword">if</span> (type != blockEntity.getType()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Block entity is not of the correct type. Expected: &quot;</span> +</span><br><span class="line">                    Registries.BLOCK_ENTITY_TYPE.getId(type) + <span class="string">&quot; but got: &quot;</span> + Registries.BLOCK_ENTITY_TYPE.getId(blockEntity.getType()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) blockEntity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> &lt;T <span class="keyword">extends</span> <span class="title class_">BlockEntity</span>&gt; T <span class="title function_">getBlockEntity</span><span class="params">(Class&lt;T&gt; baseClass, PlayerEntity player)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isWithinDistance(player, <span class="number">64</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Player cannot use this block entity as its too far away&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">BlockEntity</span> <span class="variable">blockEntity</span> <span class="operator">=</span> getBlockEntity(player);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!baseClass.isInstance(blockEntity)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Block entity is not of the correct class&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//noinspection unchecked</span></span><br><span class="line">        <span class="keyword">return</span> (T) blockEntity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> BlockEntity <span class="title function_">getBlockEntity</span><span class="params">(PlayerEntity player)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isWithinDistance(player, <span class="number">64</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Player cannot use this block entity as its too far away&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">BlockEntity</span> <span class="variable">blockEntity</span> <span class="operator">=</span> player.getWorld().getBlockEntity(pos());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (blockEntity == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Block entity is null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> blockEntity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，这里是搬了<code>科技复兴</code>（Tech Reborn）的核心库里面的一个接口，用于传递<code>BlockPos</code>，我们这里也是直接拿来用，遵循其<code>MIT</code>协议</p>
<p>因为我其实对网络通信并不清楚，而<code>1.21</code>又大改一通，这下只能借助强大的开源社区了qwq</p>
<h2 id="创建PolishingMachineData类"><a href="#创建PolishingMachineData类" class="headerlink" title="创建PolishingMachineData类"></a>创建PolishingMachineData类</h2><p>这个是待会用到的用于数据传输的类，因为在<code>1.21</code>里面，源代码又改了，现在需要我们自己去实现这个数据类，所以我们需要自己写一个</p>
<p>这个是用于网络通信的数据编解码器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">PolishingMachineData</span><span class="params">(BlockPos pos)</span> <span class="keyword">implements</span> <span class="title class_">BlockPosPayload</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> PacketCodec&lt;RegistryByteBuf, PolishingMachineData&gt; CODEC=</span><br><span class="line">        PacketCodec.tuple(BlockPos.PACKET_CODEC, PolishingMachineData::pos, PolishingMachineData::<span class="keyword">new</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类是一个<code>record</code>类，它的作用是传递<code>BlockPos</code>，实现了<code>BlockPosPayload</code>接口</p>
<p><code>PacketCodec</code>是一个编解码器，它的作用是将数据编码成<code>ByteBuf</code>，然后传输给客户端或服务端</p>
<p>这里我们传递的是<code>BlockPos</code>，所以我们用<code>BlockPos.PACKET_CODEC</code>来编解码<code>BlockPos</code></p>
<h1 id="方块实体"><a href="#方块实体" class="headerlink" title="方块实体"></a>方块实体</h1><h2 id="创建PolishingMachineBlockEntity类"><a href="#创建PolishingMachineBlockEntity类" class="headerlink" title="创建PolishingMachineBlockEntity类"></a>创建PolishingMachineBlockEntity类</h2><p>接下来我们就可以写方块实体了，我们创建一个<code>PolishingMachineBlockEntity</code>类，这个类继承自<code>BlockEntity</code>，并且实现<code>ImplementedInventory</code>接口和<code>ExtendedScreenHandlerFactory&lt;PolishingMachineData&gt;</code>接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolishingMachineBlockEntity</span> <span class="keyword">extends</span> <span class="title class_">BlockEntity</span> <span class="keyword">implements</span> <span class="title class_">ExtendedScreenHandlerFactory</span>&lt;PolishingMachineData&gt;, ImplementedInventory &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PolishingMachineBlockEntity</span><span class="params">(BlockEntityType&lt;?&gt; type, BlockPos pos, BlockState state)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(type, pos, state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> DefaultedList&lt;ItemStack&gt; <span class="title function_">getItems</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Text <span class="title function_">getDisplayName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ScreenHandler <span class="title function_">createMenu</span><span class="params">(<span class="type">int</span> syncId, PlayerInventory playerInventory, PlayerEntity player)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> PolishingMachineData <span class="title function_">getScreenOpeningData</span><span class="params">(ServerPlayerEntity player)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写好构造函数，实现一些要重写的方法</p>
<p>这里的<code>ExtendedScreenHandlerFactory&lt;PolishingMachineData&gt;</code>接口就是在<code>1.21</code>中改动的地方，现在它要求你自己写一个数据类，用于传递数据</p>
<p>另外，<code>ExtendedScreenHandlerFactory</code>是包括了网络通信的，这样我们就不用自己单独写网络发包了</p>
<h2 id="创建物品槽"><a href="#创建物品槽" class="headerlink" title="创建物品槽"></a>创建物品槽</h2><p>我们来创建方块实体中的物品槽，用于存放<code>被处理的物品</code>和<code>处理后的物品</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> DefaultedList&lt;ItemStack&gt; inventory = DefaultedList.ofSize(<span class="number">2</span>, ItemStack.EMPTY);</span><br></pre></td></tr></table></figure>
<p>这是一个<code>DefaultedList</code>，它的作用是创建一个<code>ItemStack</code>的列表，这里我们创建了一个大小为2的列表，用于存放两个物品，默认为空</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INPUT_SLOT</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">OUTPUT_SLOT</span> <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>接下来设置两个槽的<code>索引</code>（<code>一定是从0开始</code>），一个是输入槽，一个是输出槽，名字无所谓，只要你自己能够理解即可</p>
<h2 id="设置加工进度"><a href="#设置加工进度" class="headerlink" title="设置加工进度"></a>设置加工进度</h2><p>我们的方块实体是一个<code>加工机</code>，所以我们需要一个<code>加工进度</code>，用于表示物品的加工进度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> PropertyDelegate propertyDelegate;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">progress</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxProgress</span> <span class="operator">=</span> <span class="number">72</span>;</span><br></pre></td></tr></table></figure>
<p>这里我们设置了一个<code>PropertyDelegate</code>，它的作用是用于<code>同步</code>数据，这里我们用于同步<code>加工进度</code></p>
<p>下面的两个变量是<code>加工进度</code>和<code>最大加工进度</code>，这里我们设置了一个<code>72</code>，也就是<code>3.6s</code></p>
<h2 id="初始化加工进度的同步"><a href="#初始化加工进度的同步" class="headerlink" title="初始化加工进度的同步"></a>初始化加工进度的同步</h2><p>我们在构造函数中初始化<code>propertyDelegate</code>，设置<code>加工进度</code>的同步</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.propertyDelegate = <span class="keyword">new</span> <span class="title class_">PropertyDelegate</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">switch</span> (index) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span> -&gt; PolishingMachineBlockEntity.<span class="built_in">this</span>.progress;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span> -&gt; PolishingMachineBlockEntity.<span class="built_in">this</span>.maxProgress;</span><br><span class="line">            <span class="keyword">default</span> -&gt; <span class="number">0</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (index) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span> -&gt; PolishingMachineBlockEntity.<span class="built_in">this</span>.progress = value;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span> -&gt; PolishingMachineBlockEntity.<span class="built_in">this</span>.maxProgress = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里我们重写了<code>PropertyDelegate</code>的三个方法，<code>get</code>用于获取数据，<code>set</code>用于设置数据，<code>size</code>用于设置数据的数量</p>
<h2 id="重写getItems方法"><a href="#重写getItems方法" class="headerlink" title="重写getItems方法"></a>重写<code>getItems</code>方法</h2><p>我们重写<code>getItems</code>方法，返回我们的物品槽列表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> DefaultedList&lt;ItemStack&gt; <span class="title function_">getItems</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">this</span>.inventory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="重写getDisplayName方法"><a href="#重写getDisplayName方法" class="headerlink" title="重写getDisplayName方法"></a>重写<code>getDisplayName</code>方法</h2><p>我们重写<code>getDisplayName</code>方法，返回我们的方块实体显示在GUI上的名字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Text <span class="title function_">getDisplayName</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> Text.translatable(<span class="string">&quot;container.polishing_machine&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个待会会拿语言文件翻译</p>
<h2 id="重写getScreenOpeningData方法"><a href="#重写getScreenOpeningData方法" class="headerlink" title="重写getScreenOpeningData方法"></a>重写<code>getScreenOpeningData</code>方法</h2><p>我们重写<code>getScreenOpeningData</code>方法，返回我们的数据类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> PolishingMachineData <span class="title function_">getScreenOpeningData</span><span class="params">(ServerPlayerEntity player)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PolishingMachineData</span>(pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="重写writeNbt和readNbt方法"><a href="#重写writeNbt和readNbt方法" class="headerlink" title="重写writeNbt和readNbt方法"></a>重写<code>writeNbt</code>和<code>readNbt</code>方法</h2><p>这两个方法是用于数据的<code>读写</code>，当我们保存世界的时候，如果方块实体里面有东西，那么我们需要将这些东西保存下来，当我们加载世界的时候，我们需要将这些东西读取出来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">writeNbt</span><span class="params">(NbtCompound nbt, RegistryWrapper.WrapperLookup registryLookup)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.writeNbt(nbt, registryLookup);</span><br><span class="line">    Inventories.writeNbt(nbt, <span class="built_in">this</span>.inventory, <span class="literal">false</span>, registryLookup);</span><br><span class="line">    nbt.putInt(<span class="string">&quot;polishing_machine&quot;</span>, progress);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">readNbt</span><span class="params">(NbtCompound nbt, RegistryWrapper.WrapperLookup registryLookup)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.readNbt(nbt, registryLookup);</span><br><span class="line">    Inventories.readNbt(nbt, <span class="built_in">this</span>.inventory, registryLookup);</span><br><span class="line">    progress = nbt.getInt(<span class="string">&quot;polishing_machine&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面的参数写法可以参考源代码的，较比<code>1.20</code>也是有所改动的</p>
<h2 id="重写getMaxCountPerStack方法"><a href="#重写getMaxCountPerStack方法" class="headerlink" title="重写getMaxCountPerStack方法"></a>重写<code>getMaxCountPerStack</code>方法</h2><p>这个方法是用于设置物品槽中物品的最大数量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMaxCountPerStack</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">64</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们设置为<code>64</code>，也就是一个物品槽中最多可以放64个物品</p>
<h2 id="重写tick方法"><a href="#重写tick方法" class="headerlink" title="重写tick方法"></a>重写<code>tick</code>方法</h2><p>这个方法是用于更新当前方块实体的状态，每个游戏刻都会调用这个方法，这也是方块实体的特性</p>
<p>正因为有了<code>tick</code>方法，我们才能实现方块实体的<code>加工进度</code>，<code>物品处理</code>等功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tick</span><span class="params">(World world, BlockPos pos, BlockState state)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (world.isClient()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isOutputSlotAvailable()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasRecipe()) &#123;</span><br><span class="line">            increaseCraftProgress();</span><br><span class="line">            markDirty(world, pos, state);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (hasCraftingFinished()) &#123;</span><br><span class="line">                craftItem();</span><br><span class="line">                resetProgress();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resetProgress();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resetProgress();</span><br><span class="line">        markDirty(world, pos, state);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里全是自定义的方法，我们需要自己实现，不过我们来捋一捋这里面的逻辑</p>
<ol>
<li>首先判断是否为服务端，因为运算基本上是在<code>服务端</code>进行的</li>
<li>随后判断<code>输出槽</code>是否有空位，如果<code>有空位</code>，那么我们就可以<code>进行加工</code>，没有空位的话，我们就不进行加工，直接重置加工进度</li>
<li>接下来判断<code>是否符合配方</code>（虽然上面写的是<code>has</code>，更准确来讲应该是符不符合），如果符合配方，那么我们就增加加工进度，然后保存方块实体的状态</li>
<li>再接下来判断<code>加工进度</code>是否达到<code>最大值</code>，如果达到最大值，那么我们就<code>加工物品</code>，输出相应的物品，然后<code>重置加工进度</code>，开始下一轮加工</li>
</ol>
<p>这里的逻辑就大体是这样，其实并不复杂，那么接下来我们就来实现这些方法</p>
<h2 id="实现isOutputSlotAvailable方法"><a href="#实现isOutputSlotAvailable方法" class="headerlink" title="实现isOutputSlotAvailable方法"></a>实现<code>isOutputSlotAvailable</code>方法</h2><p>这个方法是用于判断<code>输出槽</code>是否有空位</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isOutputSlotAvailable</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.getStack(OUTPUT_SLOT).isEmpty() ||</span><br><span class="line">        <span class="built_in">this</span>.getStack(OUTPUT_SLOT).getCount() &lt;= <span class="built_in">this</span>.getMaxCountPerStack();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们判断<code>输出槽</code>是否为空，或者<code>输出槽</code>的物品数量是否小于<code>最大数量</code></p>
<h2 id="实现hasRecipe方法"><a href="#实现hasRecipe方法" class="headerlink" title="实现hasRecipe方法"></a>实现<code>hasRecipe</code>方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">hasRecipe</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ItemStack</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ItemStack</span>(ModItems.ICE_ETHER);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">hasInput</span> <span class="operator">=</span> getStack(INPUT_SLOT).getItem() == Items.ICE;</span><br><span class="line">    <span class="keyword">return</span> hasInput &amp;&amp; canInsertAmountIntoOutputSlot(result) &amp;&amp; canInsertIntoOutputSlot(result.getItem());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法是用于判断是否符合配方</p>
<p>这里我们是硬编码的，在学习配方类型之后，我们就可以用json文件来定义我们的配方了</p>
<p>我们的原料是原版的<code>ICE</code>，我们的产物是我们模组的<code>ICE_ETHER</code></p>
<p><code>canInsertAmountIntoOutputSlot</code>和<code>canInsertIntoOutputSlot</code>是两个自定义的方法，用于判断是否可以将物品插入到输出槽中（主要是判断输出槽是不是满的）</p>
<h2 id="实现canInsertAmountIntoOutputSlot和canInsertIntoOutputSlot方法"><a href="#实现canInsertAmountIntoOutputSlot和canInsertIntoOutputSlot方法" class="headerlink" title="实现canInsertAmountIntoOutputSlot和canInsertIntoOutputSlot方法"></a>实现<code>canInsertAmountIntoOutputSlot</code>和<code>canInsertIntoOutputSlot</code>方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">canInsertIntoOutputSlot</span><span class="params">(Item item)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.getStack(OUTPUT_SLOT).isEmpty() ||</span><br><span class="line">        <span class="built_in">this</span>.getStack(OUTPUT_SLOT).getItem() == item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">canInsertAmountIntoOutputSlot</span><span class="params">(ItemStack result)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.getStack(OUTPUT_SLOT).getCount() + result.getCount() &lt;= <span class="built_in">this</span>.getMaxCountPerStack();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个是判断输出槽是否为空或输出槽内已有物品是否为同一个</p>
<p>后面一个是判断堆叠数量是否超过上限</p>
<h2 id="实现increaseCraftProgress方法"><a href="#实现increaseCraftProgress方法" class="headerlink" title="实现increaseCraftProgress方法"></a>实现<code>increaseCraftProgress</code>方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">increaseCraftProgress</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.progress++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法是用于增加加工进度，自增即可</p>
<h2 id="实现hasCraftingFinished方法"><a href="#实现hasCraftingFinished方法" class="headerlink" title="实现hasCraftingFinished方法"></a>实现<code>hasCraftingFinished</code>方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">hasCraftingFinished</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">this</span>.progress &gt;= <span class="built_in">this</span>.maxProgress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断当前加工进度是否达到最大值，如果是，那么就返回<code>true</code>，也就是加工完成</p>
<h2 id="实现craftItem方法"><a href="#实现craftItem方法" class="headerlink" title="实现craftItem方法"></a>实现<code>craftItem</code>方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">craftItem</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ItemStack</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ItemStack</span>(ModItems.ICE_ETHER);</span><br><span class="line">    <span class="built_in">this</span>.setStack(OUTPUT_SLOT, <span class="keyword">new</span> <span class="title class_">ItemStack</span>(result.getItem(), getStack(OUTPUT_SLOT).getCount() + result.getCount()));</span><br><span class="line">    <span class="built_in">this</span>.removeStack(INPUT_SLOT, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们还是硬编码的，我们将<code>ICE_ETHER</code>放入输出槽中，数量为<code>1</code></p>
<p>输出时，如果输出槽内有物品，则与输出槽内已有的相同物品合并数量</p>
<p>然后我们将输入槽中的物品减少<code>1</code>（视频教程忘记写了，导致出现了视频最后<code>ICE</code>不消耗的情况，看来我还是适合写bug(bushi)）</p>
<h2 id="实现resetProgress方法"><a href="#实现resetProgress方法" class="headerlink" title="实现resetProgress方法"></a>实现<code>resetProgress</code>方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resetProgress</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>.progress = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接将加工进度重置为<code>0</code>即可</p>
<h2 id="注册方块实体"><a href="#注册方块实体" class="headerlink" title="注册方块实体"></a>注册方块实体</h2><p>当然我们这里还有一个<code>createMenu</code>方法没有重写，这个放到之后写好<code>屏幕</code>和<code>屏幕处理</code>再说</p>
<p>那么现在我们来注册我们的方块实体</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> BlockEntityType&lt;PolishingMachineBlockEntity&gt; POLISHING_MACHINE_BLOCK_ENTITY = create(<span class="string">&quot;polishing_machine_block_entity&quot;</span>,</span><br><span class="line">    BlockEntityType.Builder.create(PolishingMachineBlockEntity::<span class="keyword">new</span>, ModBlocks.POLISHING_MACHINE));</span><br></pre></td></tr></table></figure>
<p>注册方法是和我们前面的一样的</p>
<p>记得<code>注册方块</code></p>
<h2 id="注册方块"><a href="#注册方块" class="headerlink" title="注册方块"></a>注册方块</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Block</span> <span class="variable">POLISHING_MACHINE</span> <span class="operator">=</span> register(<span class="string">&quot;polishing_machine&quot;</span>,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">PolishingMachine</span>(AbstractBlock.Settings.copy(Blocks.STONE)));</span><br></pre></td></tr></table></figure>
<p>方块的注册还是像往常一样</p>
<p>但是我们现在回到<code>ModBlockEntities</code>中，发现它还有报错</p>
<p>这个时候，我们还得改写PolishingMachineBlockEntity的构造函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">PolishingMachineBlockEntity</span><span class="params">(BlockPos pos, BlockState state)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">super</span>(ModBlockEntities.POLISHING_MACHINE_BLOCK_ENTITY, pos, state);</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们将原有的<code>type</code>参数去掉，直接调用我们刚刚注册的<code>BlockEntityType</code>，即<code>ModBlockEntities.POLISHING_MACHINE_BLOCK_ENTITY</code></p>
<h1 id="回到方块类"><a href="#回到方块类" class="headerlink" title="回到方块类"></a>回到方块类</h1><p>我们刚刚还剩下几个方法没有重写，现在我们来重写</p>
<h2 id="重写createBlockEntity方法"><a href="#重写createBlockEntity方法" class="headerlink" title="重写createBlockEntity方法"></a>重写<code>createBlockEntity</code>方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> BlockEntity <span class="title function_">createBlockEntity</span><span class="params">(BlockPos pos, BlockState state)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PolishingMachineBlockEntity</span>(pos, state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们返回我们刚刚注册的方块实体</p>
<h2 id="重写onStateReplaced方法"><a href="#重写onStateReplaced方法" class="headerlink" title="重写onStateReplaced方法"></a>重写<code>onStateReplaced</code>方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onStateReplaced</span><span class="params">(BlockState state, World world, BlockPos pos, BlockState newState, <span class="type">boolean</span> moved)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (state.getBlock() != newState.getBlock()) &#123;</span><br><span class="line">        <span class="type">BlockEntity</span> <span class="variable">blockEntity</span> <span class="operator">=</span> world.getBlockEntity(pos);</span><br><span class="line">        <span class="keyword">if</span> (blockEntity <span class="keyword">instanceof</span> PolishingMachineBlockEntity) &#123;</span><br><span class="line">            ItemScatterer.spawn(world, pos, (PolishingMachineBlockEntity) blockEntity);</span><br><span class="line">            world.updateComparators(pos, <span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">super</span>.onStateReplaced(state, world, pos, newState, moved);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法是用于方块被破坏时，将方块实体内的物品掉落出来</p>
<p>当然这里还有一个更新比较器的方法</p>
<h2 id="重写getTicker方法"><a href="#重写getTicker方法" class="headerlink" title="重写getTicker方法"></a>重写<code>getTicker</code>方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T <span class="keyword">extends</span> <span class="title class_">BlockEntity</span>&gt; BlockEntityTicker&lt;T&gt; <span class="title function_">getTicker</span><span class="params">(World world, BlockState state, BlockEntityType&lt;T&gt; type)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> validateTicker(type, ModBlockEntities.POLISHING_MACHINE_BLOCK_ENTITY,</span><br><span class="line">        (world1, pos, state1, blockEntity) -&gt; blockEntity.tick(world1, pos, state1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里调用的其实就是我们方块实体的<code>tick</code>方法</p>
<p><code>onUse</code>也得等到我们将<code>屏幕</code>和<code>屏幕处理</code>写好之后再写</p>
<p>那么接下来就是写<code>屏幕</code>和<code>屏幕处理</code>了</p>
<h1 id="创建三个类"><a href="#创建三个类" class="headerlink" title="创建三个类"></a>创建三个类</h1><p><code>事先说明：我们采用的GUI是和原版一样的256×256分辨率的材质，所以有些地方并不需要自己设置，比如每个小格子的大小、GUI的渲染终点等等</code></p>
<p><code>如果说你要采用不同分辨率的材质，那就需要自己设置相关的内容</code></p>
<p>我们需要创建三个类，一个是<code>屏幕</code>，一个是<code>屏幕处理</code>，一个是<code>屏幕处理注册</code></p>
<p><code>屏幕</code>是用于显示<code>GUI</code>的，就是它的渲染。GUI的材质是什么，背景怎么渲染等等这些是在这个类中完成的</p>
<p><code>屏幕处理</code>是用于处理<code>GUI</code>的，我们要在里面告诉电脑那些区域是我们的物品槽，毕竟电脑不是人，我们是看一眼就知道物品槽在这在那，但电脑不知道，所以我们要告诉它</p>
<p><code>屏幕处理注册</code>是用于注册<code>屏幕处理</code>的</p>
<h2 id="创建PolishingMachineScreenHandler类"><a href="#创建PolishingMachineScreenHandler类" class="headerlink" title="创建PolishingMachineScreenHandler类"></a>创建PolishingMachineScreenHandler类</h2><p>创建一个<code>PolishingMachineScreenHandler</code>类，这个类继承自<code>ScreenHandler</code>，并且重写<code>quickMove</code>和<code>canUse</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolishingMachineScreenHandler</span> <span class="keyword">extends</span> <span class="title class_">ScreenHandler</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PolishingMachineScreenHandler</span><span class="params">(<span class="meta">@Nullable</span> ScreenHandlerType&lt;?&gt; type, <span class="type">int</span> syncId)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(type, syncId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ItemStack <span class="title function_">quickMove</span><span class="params">(PlayerEntity player, <span class="type">int</span> slot)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canUse</span><span class="params">(PlayerEntity player)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先创建着，后面再来填充</p>
<h2 id="创建ModScreenHandlers类"><a href="#创建ModScreenHandlers类" class="headerlink" title="创建ModScreenHandlers类"></a>创建ModScreenHandlers类</h2><p>创建一个<code>ModScreenHandlers</code>类，用于注册我们的<code>屏幕处理</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ModScreenHandlers</span> &#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然这里的注册方法什么的待会再说</p>
<h2 id="创建PolishingMachineScreen类"><a href="#创建PolishingMachineScreen类" class="headerlink" title="创建PolishingMachineScreen类"></a>创建PolishingMachineScreen类</h2><p>创建一个<code>PolishingMachineScreen</code>类，这个类继承自<code>HandledScreen</code>，泛型是我们刚刚创建的<code>PolishingMachineScreenHandler</code>，并且重写<code>drawBackground</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolishingMachineScreen</span> <span class="keyword">extends</span> <span class="title class_">HandledScreen</span>&lt;PolishingMachineScreenHandler&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PolishingMachineScreen</span><span class="params">(PolishingMachineScreenHandler handler, PlayerInventory inventory, Text title)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(handler, inventory, title);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">drawBackground</span><span class="params">(DrawContext context, <span class="type">float</span> delta, <span class="type">int</span> mouseX, <span class="type">int</span> mouseY)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="PolishingMachineScreen"><a href="#PolishingMachineScreen" class="headerlink" title="PolishingMachineScreen"></a>PolishingMachineScreen</h1><p>我们先来写屏幕</p>
<h2 id="GUI材质"><a href="#GUI材质" class="headerlink" title="GUI材质"></a>GUI材质</h2><p>我们来指定GUI的材质</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Identifier</span> <span class="variable">TEXTURE</span> <span class="operator">=</span> Identifier.of(TutorialMod.MOD_ID, <span class="string">&quot;textures/gui/polishing_machine_gui.png&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>命名空间，后面加上我们材质文件的路径，<code>这里文件的后缀名也得带上</code></p>
<h2 id="重写drawBackground方法"><a href="#重写drawBackground方法" class="headerlink" title="重写drawBackground方法"></a>重写<code>drawBackground</code>方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">drawBackground</span><span class="params">(DrawContext context, <span class="type">float</span> delta, <span class="type">int</span> mouseX, <span class="type">int</span> mouseY)</span> &#123;</span><br><span class="line">    RenderSystem.setShader(GameRenderer::getPositionTexProgram);</span><br><span class="line">    RenderSystem.setShaderColor(<span class="number">1.0F</span>, <span class="number">1.0F</span>, <span class="number">1.0F</span>, <span class="number">1.0F</span>);</span><br><span class="line">    RenderSystem.setShaderTexture(<span class="number">0</span>, TEXTURE);</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> (<span class="built_in">this</span>.width - <span class="built_in">this</span>.backgroundWidth) / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> (<span class="built_in">this</span>.height - <span class="built_in">this</span>.backgroundHeight) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    context.drawTexture(TEXTURE, x, y, <span class="number">0</span>, <span class="number">0</span>, backgroundWidth, backgroundHeight);</span><br><span class="line"></span><br><span class="line">    renderProgressArrow(context, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里渲染的是<code>GUI的背景</code>，一般的，在游戏中，我们打开GUI时，背景是半透明的黑色</p>
<p><code>setShader</code>是获取游戏的渲染器</p>
<p><code>setShaderColor</code>是设置背景的<code>RGBA</code>值，不过我们这里设置成了<code>不透明</code>，也就是<code>Alpha</code>的值为<code>1</code></p>
<p><code>setShaderTexture</code>是设置要渲染的材质</p>
<p>下面的<code>x</code>和<code>y</code>是渲染<code>GUI</code>的位置，在整个游戏窗口中的位置</p>
<p><code>drawTexture</code>是渲染<code>GUI</code>，里面的两个<code>0</code>是要渲染的材质文件的起始坐标，也就是从我们的材质文件的左上角开始渲染</p>
<p>下面还有一个<code>renderProgressArrow</code>方法，这个方法是用于渲染<code>加工进度</code>的箭头的</p>
<h2 id="实现renderProgressArrow方法"><a href="#实现renderProgressArrow方法" class="headerlink" title="实现renderProgressArrow方法"></a>实现<code>renderProgressArrow</code>方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">renderProgressArrow</span><span class="params">(DrawContext context, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (handler.isCrafting() &amp;&amp; handler.isRaining()) &#123;</span><br><span class="line">        context.drawTexture(TEXTURE, x + <span class="number">85</span>, y + <span class="number">30</span>, <span class="number">176</span>, <span class="number">0</span>, <span class="number">8</span>, handler.getScaledProgress());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过这里涉及到屏幕处理程序里面的方法，先让它报错着，我们待会再写</p>
<p>一个是判断其是否<code>正在加工</code>，一个是判断当前世界是否<code>正在下雨</code>（当然，你可以自定义）</p>
<p>这里要实现的就是像熔炉那样的<code>加工进度</code>的箭头，也就是它在加工过程中，箭头会变化</p>
<p>下面的<code>drawTexture</code>和上面的是不一样，不要搞混了</p>
<p><code>x + 85</code>和<code>y + 30</code>是我们材质文件里的箭头起始的坐标</p>
<p><code>176</code>和<code>0</code>是<code>要替换</code>的箭头的起始坐标，<code>8</code>是宽度，<code>handler.getScaledProgress()</code>是高度（我们的箭头是竖着的），不过这里也是屏幕处理程序的方法</p>
<h2 id="重写render方法"><a href="#重写render方法" class="headerlink" title="重写render方法"></a>重写<code>render</code>方法</h2><p>这个我在教程中忘记讲了，不过好像也不影响</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">render</span><span class="params">(DrawContext context, <span class="type">int</span> mouseX, <span class="type">int</span> mouseY, <span class="type">float</span> delta)</span> &#123;</span><br><span class="line">    renderBackground(context, mouseX, mouseY, delta);</span><br><span class="line">    <span class="built_in">super</span>.render(context, mouseX, mouseY, delta);</span><br><span class="line">    drawMouseoverTooltip(context, mouseX, mouseY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里让它<code>渲染背景</code>和<code>显示提示信息</code></p>
<h1 id="PolishingMachineScreenHandler"><a href="#PolishingMachineScreenHandler" class="headerlink" title="PolishingMachineScreenHandler"></a>PolishingMachineScreenHandler</h1><p>接下来我们就来写屏幕处理程序</p>
<h2 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Inventory inventory;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PropertyDelegate propertyDelegate;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> PolishingMachineBlockEntity blockEntity;</span><br></pre></td></tr></table></figure>
<p>分别是<code>物品栏</code>，<code>同步数据</code>（加工进度）和<code>方块实体</code></p>
<p>然后我们改写构造函数，初始化这些方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">PolishingMachineScreenHandler</span><span class="params">(<span class="meta">@Nullable</span> ScreenHandlerType&lt;?&gt; type, <span class="type">int</span> syncId, PlayerInventory playerInventory, PropertyDelegate propertyDelegate, BlockEntity blockEntity)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(type, syncId);</span><br><span class="line">    checkSize((Inventory) blockEntity, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">this</span>.inventory = (Inventory) blockEntity;</span><br><span class="line">    inventory.onOpen(playerInventory.player);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.propertyDelegate = propertyDelegate;</span><br><span class="line">    <span class="built_in">this</span>.blockEntity = (PolishingMachineBlockEntity) blockEntity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们将形参中的<code>Inventory</code>改为<code>PlayerInventory</code>，<code>PolishingMachineBlockEntity</code>改为<code>BlockEntity</code></p>
<p>里面我们写上<code>checkSize</code>方法，这个是用于检查当前方块实体的<code>物品槽数量</code>是否与<code>预期</code>的一致（在这个例子中，预期的是<code>2</code>）</p>
<p><code>(Inventory) blockEntity</code>赋值给<code>inventory</code></p>
<p><code>inventory.onOpen</code>是打开物品栏时调用</p>
<p>还有两个也是常规的赋值</p>
<p>另外我们在这个构造函数中加入其他的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.addSlot(<span class="keyword">new</span> <span class="title class_">Slot</span>(inventory, <span class="number">0</span>, <span class="number">80</span>, <span class="number">11</span>));</span><br><span class="line"><span class="built_in">this</span>.addSlot(<span class="keyword">new</span> <span class="title class_">Slot</span>(inventory, <span class="number">1</span>, <span class="number">80</span>, <span class="number">59</span>));</span><br><span class="line"></span><br><span class="line">addPlayerInventory(playerInventory);</span><br><span class="line">addPlayerHotbar(playerInventory);</span><br><span class="line"></span><br><span class="line">addProperties(propertyDelegate);</span><br></pre></td></tr></table></figure>
<p>首先加入我们方块实体的两个槽，第二个参数是<code>索引值</code>，后面两个<code>起始坐标</code></p>
<p><code>addPlayerInventory</code>和<code>addPlayerHotbar</code>是添加玩家的<code>物品栏</code>和<code>快捷栏</code></p>
<p><code>addProperties</code>是添加同步的数据</p>
<h2 id="实现addPlayerInventory和addPlayerHotbar方法"><a href="#实现addPlayerInventory和addPlayerHotbar方法" class="headerlink" title="实现addPlayerInventory和addPlayerHotbar方法"></a>实现<code>addPlayerInventory</code>和<code>addPlayerHotbar</code>方法</h2><p>这两个其实去源代码搬一下就好了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addPlayerHotbar</span><span class="params">(PlayerInventory playerInventory)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">this</span>.addSlot(<span class="keyword">new</span> <span class="title class_">Slot</span>(playerInventory, i, <span class="number">8</span> + i * <span class="number">18</span>, <span class="number">142</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addPlayerInventory</span><span class="params">(PlayerInventory playerInventory)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">9</span>; ++j) &#123;</span><br><span class="line">            <span class="built_in">this</span>.addSlot(<span class="keyword">new</span> <span class="title class_">Slot</span>(playerInventory, j + i * <span class="number">9</span> + <span class="number">9</span>, <span class="number">8</span> + j * <span class="number">18</span>, <span class="number">84</span> + i * <span class="number">18</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实就是循环遍历，加格子</p>
<h2 id="重写quickMove方法"><a href="#重写quickMove方法" class="headerlink" title="重写quickMove方法"></a>重写<code>quickMove</code>方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ItemStack <span class="title function_">quickMove</span><span class="params">(PlayerEntity player, <span class="type">int</span> slot)</span> &#123;</span><br><span class="line">    <span class="type">ItemStack</span> <span class="variable">newStack</span> <span class="operator">=</span> ItemStack.EMPTY;</span><br><span class="line">    <span class="type">Slot</span> <span class="variable">invSlot</span> <span class="operator">=</span> <span class="built_in">this</span>.slots.get(slot);</span><br><span class="line">    <span class="keyword">if</span> (invSlot != <span class="literal">null</span> &amp;&amp; invSlot.hasStack()) &#123;</span><br><span class="line">        <span class="type">ItemStack</span> <span class="variable">originalStack</span> <span class="operator">=</span> invSlot.getStack();</span><br><span class="line">        newStack = originalStack.copy();</span><br><span class="line">        <span class="keyword">if</span> (slot &lt; <span class="built_in">this</span>.inventory.size()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">this</span>.insertItem(originalStack, <span class="built_in">this</span>.inventory.size(), <span class="built_in">this</span>.slots.size(), <span class="literal">true</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> ItemStack.EMPTY;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">this</span>.insertItem(originalStack, <span class="number">0</span>, <span class="built_in">this</span>.inventory.size(), <span class="literal">false</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> ItemStack.EMPTY;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (originalStack.isEmpty()) &#123;</span><br><span class="line">            invSlot.setStack(ItemStack.EMPTY);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            invSlot.markDirty();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newStack;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个是物品在各个物品栏之间的<code>快速移动</code>，也照搬源代码即可</p>
<h2 id="重写canUse方法"><a href="#重写canUse方法" class="headerlink" title="重写canUse方法"></a>重写<code>canUse</code>方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canUse</span><span class="params">(PlayerEntity player)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">this</span>.inventory.canPlayerUse(player);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个是用于判断玩家是否可以使用这个物品栏</p>
<h2 id="实现isCrafting和isRaining方法"><a href="#实现isCrafting和isRaining方法" class="headerlink" title="实现isCrafting和isRaining方法"></a>实现<code>isCrafting</code>和<code>isRaining</code>方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCrafting</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> propertyDelegate.get(<span class="number">0</span>) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isRaining</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> blockEntity.getWorld().isRaining();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个方法是用于判断<code>是否正在加工</code>和<code>是否正在下雨</code></p>
<h2 id="实现getScaledProgress方法"><a href="#实现getScaledProgress方法" class="headerlink" title="实现getScaledProgress方法"></a>实现<code>getScaledProgress</code>方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getScaledProgress</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">progress</span> <span class="operator">=</span> propertyDelegate.get(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxProgress</span> <span class="operator">=</span> propertyDelegate.get(<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">progressArrowSize</span> <span class="operator">=</span> <span class="number">26</span>;</span><br><span class="line">    <span class="keyword">return</span> maxProgress != <span class="number">0</span> &amp;&amp; progress != <span class="number">0</span> ? progress * progressArrowSize / maxProgress : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法是用于计算<code>加工进度</code>的箭头的高度，我们箭头的长度是<code>26</code></p>
<p>根据当前<code>加工进度</code>与<code>最大加工进度</code>的比例，计算出箭头的高度</p>
<p>在此之后，屏幕类中的报错就没有了</p>
<h1 id="ModScreenHandlers"><a href="#ModScreenHandlers" class="headerlink" title="ModScreenHandlers"></a>ModScreenHandlers</h1><p>接下来我们来注册我们的<code>屏幕处理</code></p>
<h2 id="注册屏幕处理"><a href="#注册屏幕处理" class="headerlink" title="注册屏幕处理"></a>注册屏幕处理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ScreenHandlerType&lt;PolishingMachineScreenHandler&gt; POLISHING_MACHINE_SCREEN_HANDLER =</span><br><span class="line">    Registry.register(Registries.SCREEN_HANDLER, Identifier.of(TutorialMod.MOD_ID, <span class="string">&quot;polishing_machine&quot;</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ExtendedScreenHandlerType</span>&lt;&gt;(PolishingMachineScreenHandler::<span class="keyword">new</span>, PolishingMachineData.CODEC));</span><br></pre></td></tr></table></figure>
<p>这里我们注册了一个<code>屏幕处理</code>，并且传入了我们的<code>屏幕处理</code>和<code>数据编解码器</code></p>
<p>但是现在它会报错，这个时候我们还得<code>再</code>写一个<code>PolishingMachineScreenHandler</code>的构造函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">PolishingMachineScreenHandler</span><span class="params">(<span class="type">int</span> syncId, PlayerInventory playerInventory, PolishingMachineData data)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(syncId, playerInventory, <span class="keyword">new</span> <span class="title class_">ArrayPropertyDelegate</span>(<span class="number">2</span>), playerInventory.player.getWorld().getBlockEntity(data.pos()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个构造函数就可以被我们的注册方法调用了，这里的报错也就解决了</p>
<h2 id="初始化注册方法"><a href="#初始化注册方法" class="headerlink" title="初始化注册方法"></a>初始化注册方法</h2><p>和常规一样，不要忘了初始化注册方法及其主类的调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerScreenHandlers</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="调用注册方法"><a href="#调用注册方法" class="headerlink" title="调用注册方法"></a>调用注册方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ModScreenHandlers.registerScreenHandlers();</span><br></pre></td></tr></table></figure>

<h1 id="方块类onUse方法"><a href="#方块类onUse方法" class="headerlink" title="方块类onUse方法"></a>方块类<code>onUse</code>方法</h1><p>现在我们回到方块类，来写<code>onUse</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> ActionResult <span class="title function_">onUse</span><span class="params">(BlockState state, World world, BlockPos pos, PlayerEntity player, BlockHitResult hit)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!world.isClient())&#123;</span><br><span class="line">        <span class="type">NamedScreenHandlerFactory</span> <span class="variable">screenHandlerFactory</span> <span class="operator">=</span> (PolishingMachineBlockEntity) world.getBlockEntity(pos);</span><br><span class="line">        <span class="keyword">if</span> (screenHandlerFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">            player.openHandledScreen(screenHandlerFactory);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ActionResult.SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法是用于打开<code>GUI</code>的，当玩家右键点击方块时，打开<code>GUI</code></p>
<p>这里我们判断<code>是否为服务端</code>，然后获取<code>方块实体</code>，如果<code>方块实体</code>不为空，那么就打开<code>GUI</code></p>
<h1 id="方块实体类createMenu方法"><a href="#方块实体类createMenu方法" class="headerlink" title="方块实体类createMenu方法"></a>方块实体类<code>createMenu</code>方法</h1><p>接下来我们来写<code>方块实体</code>的<code>createMenu</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ScreenHandler <span class="title function_">createMenu</span><span class="params">(<span class="type">int</span> syncId, PlayerInventory playerInventory, PlayerEntity player)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PolishingMachineScreenHandler</span>(syncId, playerInventory, <span class="built_in">this</span>.propertyDelegate, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法是用于创建<code>屏幕处理</code>，我们在这里传入了<code>同步数据</code>和<code>方块实体</code></p>
<h1 id="客户端注册屏幕渲染"><a href="#客户端注册屏幕渲染" class="headerlink" title="客户端注册屏幕渲染"></a>客户端注册屏幕渲染</h1><p>接下来还有一件事是注册客户端的屏幕渲染，因为渲染一事是在客户端进行的</p>
<p>我们到<code>TutorialModClient</code>中，注册我们的屏幕渲染</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HandledScreens.register(ModScreenHandlers.POLISHING_MACHINE_SCREEN_HANDLER, PolishingMachineScreen::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>
<p>这里我们注册了我们的<code>屏幕处理</code>和<code>屏幕</code>，这样我们的<code>GUI</code>就可以显示出来了</p>
<h1 id="数据文件"><a href="#数据文件" class="headerlink" title="数据文件"></a>数据文件</h1><p>最后的最后，收尾工作了</p>
<h2 id="语言文件"><a href="#语言文件" class="headerlink" title="语言文件"></a>语言文件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">translationBuilder.add(ModBlocks.POLISHING_MACHINE, <span class="string">&quot;Polishing Machine&quot;</span>);</span><br><span class="line">translationBuilder.add(<span class="string">&quot;container.polishing_machine&quot;</span>, <span class="string">&quot;Polishing Machine&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这里我们添加了<code>方块</code>和<code>GUI</code>的翻译</p>
<h2 id="模型文件"><a href="#模型文件" class="headerlink" title="模型文件"></a>模型文件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blockStateModelGenerator.registerSimpleState(ModBlocks.POLISHING_MACHINE);</span><br></pre></td></tr></table></figure>
<p>因为是拿BlockBench做的方块模型，所以这里就写最简单的方块状态即可</p>
<h2 id="材质文件"><a href="#材质文件" class="headerlink" title="材质文件"></a>材质文件</h2><p>GUI的话就是我们前面写的路径，方块的材质放在对应的文件夹下面即可</p>
<p><code>最后也感谢大家看完，虽然我也写得半条命没了</code></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://beishanair.github.io">BeiShan_Besson</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://beishanair.github.io/2024/10/26/121/polishingmachine121/">https://beishanair.github.io/2024/10/26/121/polishingmachine121/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://beishanair.github.io" target="_blank">Tomorrow-Land</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Fabric/">Fabric</a></div><div class="post_share"><div class="social-share" data-image="/pic/121/031.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/10/25/121/jar121/" title="Jar构建 1.21 Fabric"><img class="cover" src="/pic/121/030.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Jar构建 1.21 Fabric</div></div></a></div><div class="next-post pull-right"><a href="/2024/10/27/121/recipetype121/" title="自定义配方类型 1.21 Fabric"><img class="cover" src="/pic/121/032.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">自定义配方类型 1.21 Fabric</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2025/02/19/120/120/" title="前言 1.20 Fabric 长线教程计划"><img class="cover" src="/pic/120/0000.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-19</div><div class="title">前言 1.20 Fabric 长线教程计划</div></div></a></div><div><a href="/2025/04/20/120/block120/" title="第一个方块 1.20 Fabric 长线教程计划"><img class="cover" src="/pic/120/0004.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-20</div><div class="title">第一个方块 1.20 Fabric 长线教程计划</div></div></a></div><div><a href="/2025/04/16/120/item120/" title="第一个物品 1.20 Fabric 长线教程计划"><img class="cover" src="/pic/120/0002.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-16</div><div class="title">第一个物品 1.20 Fabric 长线教程计划</div></div></a></div><div><a href="/2025/04/17/120/itemgroup120/" title="创造模式物品栏 1.20 Fabric 长线教程计划"><img class="cover" src="/pic/120/0003.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-17</div><div class="title">创造模式物品栏 1.20 Fabric 长线教程计划</div></div></a></div><div><a href="/2025/04/15/120/start120/" title="开发环境配置 1.20 Fabric 长线教程计划"><img class="cover" src="/pic/120/0001.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-15</div><div class="title">开发环境配置 1.20 Fabric 长线教程计划</div></div></a></div><div><a href="/2024/10/12/121/armor121/" title="自定义盔甲 1.21 Fabric"><img class="cover" src="/pic/121/017.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-12</div><div class="title">自定义盔甲 1.21 Fabric</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/pic/BS.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">BeiShan_Besson</div><div class="author-info__description">今天你写代码了吗？</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">68</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/BeiShanair"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/BeiShanair" target="_blank" title="Github"><i class="fab fa-github" style="color: #FFFFFF;"></i></a><a class="social-icon" href="mailto:besson_arch@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://space.bilibili.com/489671468" target="_blank" title="Bilibili"><i class="fab fa-bilibili" style="color: #FF679A;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客！如有问题请加交流频道：pd09376785</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%AC%E7%AF%87%E6%95%99%E7%A8%8B%E7%9A%84%E8%A7%86%E9%A2%91"><span class="toc-number">1.</span> <span class="toc-text">本篇教程的视频</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%AC%E7%AF%87%E6%95%99%E7%A8%8B%E7%9A%84%E6%BA%90%E4%BB%A3%E7%A0%81"><span class="toc-number">2.</span> <span class="toc-text">本篇教程的源代码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Github%E5%9C%B0%E5%9D%80%EF%BC%9ATutorialMod-PolishingMachine-1-21"><span class="toc-number">2.1.</span> <span class="toc-text">Github地址：TutorialMod-PolishingMachine-1.21</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%B9%E5%9D%97%E7%B1%BB"><span class="toc-number">4.</span> <span class="toc-text">方块类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAPolishingMachine%E7%B1%BB"><span class="toc-number">4.1.</span> <span class="toc-text">创建PolishingMachine类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="toc-number">4.2.</span> <span class="toc-text">设置编解码器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E7%A2%B0%E6%92%9E%E7%AE%B1"><span class="toc-number">4.3.</span> <span class="toc-text">设置碰撞箱</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E6%B8%B2%E6%9F%93"><span class="toc-number">4.4.</span> <span class="toc-text">设置渲染</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E7%8A%B6%E6%80%81%E6%94%B9%E5%8F%98"><span class="toc-number">4.5.</span> <span class="toc-text">设置状态改变</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">4.6.</span> <span class="toc-text">设置使用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AETicker"><span class="toc-number">4.7.</span> <span class="toc-text">设置Ticker</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ImplementedInventory"><span class="toc-number">5.</span> <span class="toc-text">ImplementedInventory</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB"><span class="toc-number">6.</span> <span class="toc-text">数据类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BABlockPosPayload%E7%B1%BB"><span class="toc-number">6.1.</span> <span class="toc-text">创建BlockPosPayload类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAPolishingMachineData%E7%B1%BB"><span class="toc-number">6.2.</span> <span class="toc-text">创建PolishingMachineData类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%B9%E5%9D%97%E5%AE%9E%E4%BD%93"><span class="toc-number">7.</span> <span class="toc-text">方块实体</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAPolishingMachineBlockEntity%E7%B1%BB"><span class="toc-number">7.1.</span> <span class="toc-text">创建PolishingMachineBlockEntity类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%89%A9%E5%93%81%E6%A7%BD"><span class="toc-number">7.2.</span> <span class="toc-text">创建物品槽</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%8A%A0%E5%B7%A5%E8%BF%9B%E5%BA%A6"><span class="toc-number">7.3.</span> <span class="toc-text">设置加工进度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8A%A0%E5%B7%A5%E8%BF%9B%E5%BA%A6%E7%9A%84%E5%90%8C%E6%AD%A5"><span class="toc-number">7.4.</span> <span class="toc-text">初始化加工进度的同步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%86%99getItems%E6%96%B9%E6%B3%95"><span class="toc-number">7.5.</span> <span class="toc-text">重写getItems方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%86%99getDisplayName%E6%96%B9%E6%B3%95"><span class="toc-number">7.6.</span> <span class="toc-text">重写getDisplayName方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%86%99getScreenOpeningData%E6%96%B9%E6%B3%95"><span class="toc-number">7.7.</span> <span class="toc-text">重写getScreenOpeningData方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%86%99writeNbt%E5%92%8CreadNbt%E6%96%B9%E6%B3%95"><span class="toc-number">7.8.</span> <span class="toc-text">重写writeNbt和readNbt方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%86%99getMaxCountPerStack%E6%96%B9%E6%B3%95"><span class="toc-number">7.9.</span> <span class="toc-text">重写getMaxCountPerStack方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%86%99tick%E6%96%B9%E6%B3%95"><span class="toc-number">7.10.</span> <span class="toc-text">重写tick方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0isOutputSlotAvailable%E6%96%B9%E6%B3%95"><span class="toc-number">7.11.</span> <span class="toc-text">实现isOutputSlotAvailable方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0hasRecipe%E6%96%B9%E6%B3%95"><span class="toc-number">7.12.</span> <span class="toc-text">实现hasRecipe方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0canInsertAmountIntoOutputSlot%E5%92%8CcanInsertIntoOutputSlot%E6%96%B9%E6%B3%95"><span class="toc-number">7.13.</span> <span class="toc-text">实现canInsertAmountIntoOutputSlot和canInsertIntoOutputSlot方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0increaseCraftProgress%E6%96%B9%E6%B3%95"><span class="toc-number">7.14.</span> <span class="toc-text">实现increaseCraftProgress方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0hasCraftingFinished%E6%96%B9%E6%B3%95"><span class="toc-number">7.15.</span> <span class="toc-text">实现hasCraftingFinished方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0craftItem%E6%96%B9%E6%B3%95"><span class="toc-number">7.16.</span> <span class="toc-text">实现craftItem方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0resetProgress%E6%96%B9%E6%B3%95"><span class="toc-number">7.17.</span> <span class="toc-text">实现resetProgress方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E6%96%B9%E5%9D%97%E5%AE%9E%E4%BD%93"><span class="toc-number">7.18.</span> <span class="toc-text">注册方块实体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E6%96%B9%E5%9D%97"><span class="toc-number">7.19.</span> <span class="toc-text">注册方块</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9E%E5%88%B0%E6%96%B9%E5%9D%97%E7%B1%BB"><span class="toc-number">8.</span> <span class="toc-text">回到方块类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%86%99createBlockEntity%E6%96%B9%E6%B3%95"><span class="toc-number">8.1.</span> <span class="toc-text">重写createBlockEntity方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%86%99onStateReplaced%E6%96%B9%E6%B3%95"><span class="toc-number">8.2.</span> <span class="toc-text">重写onStateReplaced方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%86%99getTicker%E6%96%B9%E6%B3%95"><span class="toc-number">8.3.</span> <span class="toc-text">重写getTicker方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%89%E4%B8%AA%E7%B1%BB"><span class="toc-number">9.</span> <span class="toc-text">创建三个类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAPolishingMachineScreenHandler%E7%B1%BB"><span class="toc-number">9.1.</span> <span class="toc-text">创建PolishingMachineScreenHandler类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAModScreenHandlers%E7%B1%BB"><span class="toc-number">9.2.</span> <span class="toc-text">创建ModScreenHandlers类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAPolishingMachineScreen%E7%B1%BB"><span class="toc-number">9.3.</span> <span class="toc-text">创建PolishingMachineScreen类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#PolishingMachineScreen"><span class="toc-number">10.</span> <span class="toc-text">PolishingMachineScreen</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#GUI%E6%9D%90%E8%B4%A8"><span class="toc-number">10.1.</span> <span class="toc-text">GUI材质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%86%99drawBackground%E6%96%B9%E6%B3%95"><span class="toc-number">10.2.</span> <span class="toc-text">重写drawBackground方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0renderProgressArrow%E6%96%B9%E6%B3%95"><span class="toc-number">10.3.</span> <span class="toc-text">实现renderProgressArrow方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%86%99render%E6%96%B9%E6%B3%95"><span class="toc-number">10.4.</span> <span class="toc-text">重写render方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#PolishingMachineScreenHandler"><span class="toc-number">11.</span> <span class="toc-text">PolishingMachineScreenHandler</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F"><span class="toc-number">11.1.</span> <span class="toc-text">定义变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0addPlayerInventory%E5%92%8CaddPlayerHotbar%E6%96%B9%E6%B3%95"><span class="toc-number">11.2.</span> <span class="toc-text">实现addPlayerInventory和addPlayerHotbar方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%86%99quickMove%E6%96%B9%E6%B3%95"><span class="toc-number">11.3.</span> <span class="toc-text">重写quickMove方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%86%99canUse%E6%96%B9%E6%B3%95"><span class="toc-number">11.4.</span> <span class="toc-text">重写canUse方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0isCrafting%E5%92%8CisRaining%E6%96%B9%E6%B3%95"><span class="toc-number">11.5.</span> <span class="toc-text">实现isCrafting和isRaining方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0getScaledProgress%E6%96%B9%E6%B3%95"><span class="toc-number">11.6.</span> <span class="toc-text">实现getScaledProgress方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ModScreenHandlers"><span class="toc-number">12.</span> <span class="toc-text">ModScreenHandlers</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E5%B1%8F%E5%B9%95%E5%A4%84%E7%90%86"><span class="toc-number">12.1.</span> <span class="toc-text">注册屏幕处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B3%A8%E5%86%8C%E6%96%B9%E6%B3%95"><span class="toc-number">12.2.</span> <span class="toc-text">初始化注册方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E6%B3%A8%E5%86%8C%E6%96%B9%E6%B3%95"><span class="toc-number">12.3.</span> <span class="toc-text">调用注册方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%B9%E5%9D%97%E7%B1%BBonUse%E6%96%B9%E6%B3%95"><span class="toc-number">13.</span> <span class="toc-text">方块类onUse方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%B9%E5%9D%97%E5%AE%9E%E4%BD%93%E7%B1%BBcreateMenu%E6%96%B9%E6%B3%95"><span class="toc-number">14.</span> <span class="toc-text">方块实体类createMenu方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B3%A8%E5%86%8C%E5%B1%8F%E5%B9%95%E6%B8%B2%E6%9F%93"><span class="toc-number">15.</span> <span class="toc-text">客户端注册屏幕渲染</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6"><span class="toc-number">16.</span> <span class="toc-text">数据文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6"><span class="toc-number">16.1.</span> <span class="toc-text">语言文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E6%96%87%E4%BB%B6"><span class="toc-number">16.2.</span> <span class="toc-text">模型文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%90%E8%B4%A8%E6%96%87%E4%BB%B6"><span class="toc-number">16.3.</span> <span class="toc-text">材质文件</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/05/07/120/jar120/" title="Jar打包 1.20 Fabric 长线教程计划"><img src="/pic/120/0011.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Jar打包 1.20 Fabric 长线教程计划"/></a><div class="content"><a class="title" href="/2025/05/07/120/jar120/" title="Jar打包 1.20 Fabric 长线教程计划">Jar打包 1.20 Fabric 长线教程计划</a><time datetime="2025-05-06T17:00:00.000Z" title="发表于 2025-05-07 01:00:00">2025-05-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/07/120/tag120/" title="Tags·标签 1.20 Fabric 长线教程计划"><img src="/pic/120/0010.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Tags·标签 1.20 Fabric 长线教程计划"/></a><div class="content"><a class="title" href="/2025/05/07/120/tag120/" title="Tags·标签 1.20 Fabric 长线教程计划">Tags·标签 1.20 Fabric 长线教程计划</a><time datetime="2025-05-06T16:00:00.000Z" title="发表于 2025-05-07 00:00:00">2025-05-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/06/120/fuel120/" title="燃料 1.20 Fabric 长线教程计划"><img src="/pic/120/0009.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="燃料 1.20 Fabric 长线教程计划"/></a><div class="content"><a class="title" href="/2025/05/06/120/fuel120/" title="燃料 1.20 Fabric 长线教程计划">燃料 1.20 Fabric 长线教程计划</a><time datetime="2025-05-06T08:00:00.000Z" title="发表于 2025-05-06 16:00:00">2025-05-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/06/120/food120/" title="食物 1.20 Fabric 长线教程计划"><img src="/pic/120/0008.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="食物 1.20 Fabric 长线教程计划"/></a><div class="content"><a class="title" href="/2025/05/06/120/food120/" title="食物 1.20 Fabric 长线教程计划">食物 1.20 Fabric 长线教程计划</a><time datetime="2025-05-06T07:00:00.000Z" title="发表于 2025-05-06 15:00:00">2025-05-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/25/120/datagen120/" title="数据生成 1.20 Fabric 长线教程计划"><img src="/pic/120/0007.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据生成 1.20 Fabric 长线教程计划"/></a><div class="content"><a class="title" href="/2025/04/25/120/datagen120/" title="数据生成 1.20 Fabric 长线教程计划">数据生成 1.20 Fabric 长线教程计划</a><time datetime="2025-04-25T07:00:00.000Z" title="发表于 2025-04-25 15:00:00">2025-04-25</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By BeiShan_Besson</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>